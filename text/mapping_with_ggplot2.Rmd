---
title: 'mapping_with_ggplot2'
author: 'Robert Schlegel'
date: '17 July 2017'
output: 
  html_document:
    keep_md: true
---

```{r, echo=FALSE}
knitr::opts_chunk$set(
  fig.path = '../figures/',
  cache = FALSE,
  warning = FALSE, 
  message = FALSE
)
```

## Objective
There are many different things that scientists need to use programming languages (like R) for. Far too many to count here. There is however one common use amongst almost all physical and biological scientists: mapping. Almost every report, research project or paper that occurs within a study area will have, as "Figure 1", a map of that area. To this end whenever I teach R, or run workshops on it, one of the questions I am always prepared for is how to create a map of a particular area. Being a happy convert to the [tidyverse](https://cran.r-project.org/web/packages/tidyverse/) I only teach the graphics of [ggplot2](https://cran.r-project.org/web/packages/ggplot2/). I have found that people often prefer to use the [ggmap](https://cran.r-project.org/web/packages/ggmap/) extension to create ggplot quality figures with google map backgrounds, but I personally think that a more traditional monotone background for maps looks more professional. What I've decided to showcase this week is the data and code required to create a publication quality map. Indeed, the following code will create the aforementioned obligaotry "Figure 1" in a paper I am currently preparing for submission.

## Data
There are heaps of packages etc. that one may use to create maps. And there is a never ending source for blogs, books and tutorials that illustrate many of the different ways to visualise spatial data. For my international and geographic borders I prefer to use data I've downloaded from [GSHHSG](https://www.ngdc.noaa.gov/mgg/shorelines/gshhs.html) and then converted to dataframes using functions found in the [PBSmapping](https://cran.r-project.org/web/packages/PBSmapping/) package. I then save these converted dataframes as .Rdata objects on my computer for ease of use with all of my projects. For the domestic borders of a country, which I won't use in this post, one may go [here](http://gadm.org/). Note however that for some strange reason this website still has the pre-1994 borders for South Africa. For the correct SA borders one must go [here](http://www.demarcation.org.za/index.php/downloads/boundary-data/boundary-data-main-files/province). The current SA borders may actually be download in the .Rdata format, which is neat.

Once one has the borders to be used in the map, the next step is to think about what one actually wants to show. The main purpose of this map is to show where several in situ coastal seawater temperature time series were collected. This could be done quite simply but a plain black and white map is ofensively boring so we want to make sure there is a good amount (but not too much!) colour in order to entice the reader. I personally find pictures of meso-scale oceanic phenomena particularly beautiful so try to include them whenever I can. Luckily that is also what I study so it is not strange that I include such things in my work. Now if only I also studied panda's, too... 

Panda's aside, the current work I am engaged in also requires that the atmospheric processes around southern Africa also be considered. In order to visualise both are and sea concurrently would be a mess so we will want to create two panels. Because I have been working with reanalysis data lately, and not satellite data, I am also able to include the wind/ current vectors for each pixel in order to really help the temperature patterns pop. The oceanic data are from the [BRAN2016](wp.csiro.au/bluelink) product and the atmospheric data are from [ERA-Interim](http://www.ecmwf.int/en/research/climate-reanalysis/era-interim). Both of which are available for download for free for scientific pursuits. I've chosen here to use the mean values from January 1st as the summer months provide the most clear example of the thermal differences between the Agulhas and Benguela currents. The code used to create the scale bar in the maps may be found [here](http://editerna.free.fr/wp/?p=76). It's not a proper ggplot geom function but works well enough.

```{r mg-load}
## Libraries
library(tidyverse)
library(viridis)
library(gridExtra)

## Data
# South Africa map data
load("../data/southern_africa_coast.Rdata") # Lowres
names(southern_africa_coast)[1] <- "lon"
load("../data/sa_shore.Rdata") # Hires
names(sa_shore)[4:5] <- c("lon","lat")

# International borders
load("../data/africa_borders.Rdata")

# Reanalysis data
load("../data/all_jan1_0.5.Rdata")
names(all_jan1_0.5)[1:2] <- c("lon","lat")

# In situ time series locations
site_list <- read_csv("../data/mg_site_list.csv")
site_list$order <- 1:nrow(site_list)

# Bathymetry data
load("../data/sa_bathy.Rdata")

## Scale bar function
source("../func/scale.bar.func.R")
```

## Mapping
I find that it is easier to keep track of the different aspects of a map when they are stored as different dataframes. One should however avoid having too many loose dataframes running about in the global environment. It is a balancing act and requires one to find a happy middle ground. Here I am going to cut the `all_jan1_0.5` dataframes into 4. One each for air and sea temperature and movement. I am also going to reduce the resolution of the wind/ currents so that the vectors will plot more nicely.

```{r mg-prep}
# Devide the reanalysis data
sea_temp <- filter(all_jan1_0.5, variable == "BRAN/temp")
air_temp <- filter(all_jan1_0.5, variable == "ERA/temp")
currents <- filter(all_jan1_0.5, variable == "BRAN/u" | variable == "BRAN/v") %>% 
  select(-date, -index) %>% 
  spread(key = variable, value = value) %>% 
  rename(u = "BRAN/u", v = "BRAN/v")
winds <- filter(all_jan1_0.5, variable == "ERA/u" | variable == "ERA/v") %>% 
  select(-date, -index) %>% 
  spread(key = variable, value = value) %>% 
  rename(u = "ERA/u", v = "ERA/v")

# Reduce wind/ current vectors
lon_sub <- seq(10, 40, by = 1)
lat_sub <- seq(-40, -15, by = 1)
# currents <- currents[(currents$lon %in% lon_sub & currents$lat %in% lat_sub),]
winds <- winds[(winds$lon %in% lon_sub & winds$lat %in% lat_sub),]
```

With just a few alterations to our nicely devided up dataframes we are ready to create a map. I've decided here to simply show all of the code in one well annotated chunk, rather than taking a more step by step approach.

```{r mg-top}
# Establish the vector scalar for the currents
current_uv_scalar <- 2

# The top figure (sea)
mg_top <- ggplot(data = southern_africa_coast, aes(x = lon, y = lat)) +
  # The ocean temperature
    geom_raster(data = sea_temp, aes(fill = value)) +
  # The bathymetry
    stat_contour(data = sa_bathy[sa_bathy$depth < -200 & sa_bathy$depth > -2000,], 
                 aes(x = lon, y = lat, z = depth, alpha = ..level..),
                 colour = "ivory", size = 0.5, binwidth = 1000, na.rm = TRUE, show.legend = FALSE) +
  # The current vectors
    geom_segment(data = currents, aes(xend = lon + u * current_uv_scalar, yend = lat + v * current_uv_scalar),
                 arrow = arrow(angle = 15, length = unit(0.02, "inches"), type = "closed"), alpha = 0.4) +
  # The land mass
    geom_polygon(aes(group = group), fill = "grey70", colour = "black", size = 0.5, show.legend = FALSE) +
    geom_path(data = africa_borders, aes(group = group)) +
  # The legend for the vector length
    geom_label(aes(x = 36, y = -37, label = "1.0 m/s\n"), size = 4, label.padding = unit(0.5, "lines")) +
    geom_segment(aes(x = 35, y = -37.5, xend = 37, yend = -37.5)) +
  # The in situ sites
    geom_point(data = site_list, shape = 1,  size = 2.6, colour = "ivory") +
    geom_text(data = site_list, aes(label = order), size = 2.0, colour = "ivory") +
  # Improve on the x and y axis labels
    scale_x_continuous(breaks = seq(15, 35, 5),
                       labels = scales::unit_format("°E", sep = ""),
                       position = "top") +
    scale_y_continuous(breaks = seq(-35, -30, 5),
                       labels = c("35°S", "30°S")) +
    labs(x = NULL, y = NULL) +
  # Slightly shrink the plotting area
    coord_cartesian(xlim = c(10.5, 39.5), ylim = c(-39.5, -25.5), expand = F) +
  # Use viridis colour scheme
    scale_fill_viridis(name = "Temp.\n(°C)", option = "D") +
  # Adjust the theme
    theme_bw() +
    theme(panel.border = element_rect(fill = NA, colour = "black", size = 1))#,
          # plot.title = element_text(hjust = 0.5, size = 12),
    #       panel.background = element_rect(fill = "grey70"),
    #       panel.grid.major = element_line(colour = "grey70"),
    #       panel.grid.minor = element_line(colour = "grey70"),
    #       legend.position = "right",
    #       legend.direction = "vertical",
    #       strip.text = element_text(size = 12),
    #       strip.background = element_rect(fill = NA),
    #       legend.key.height = unit(1.1, "cm"),
    #       axis.text = element_text(size = 12),
    #       legend.text = element_text(size = 12),
    #       legend.title = element_text(size = 12))
# mg_top
ggsave("../figures/mg_top.pdf")

# False Bay inset
fb <- ggplot(data = sa_shore, aes(x = lon, y = lat)) +
  # The land mass
    geom_polygon(aes(group = PID),
                fill = "grey70", colour = NA, size = 0.5, show.legend = FALSE) +
  # The in situ sites
    geom_point(data = site_list, shape = 1,  size = 3, colour = "black") +
    geom_text(data = site_list, aes(label = order), size = 2.4, colour = "black") +
  # Text label
    geom_text(aes(x = 18.65, y = -34.25, label = "False\nBay"), size = 2.8) +
  # Control the x and y axes
    coord_cartesian(xlim = c(18, 19), ylim = c(-34.5, -33.8), expand = F) +
    scale_x_continuous(breaks = c(18.5), label = "18.5°E") +
    scale_y_continuous(breaks = c(-34.1), label = "34.1°S") +
    labs(x = NULL, y = NULL) +
  # Change the theme for cleaner over-plotting
    theme_bw() +
    theme(plot.background = element_blank(),
          axis.text = element_text(colour = "ivory"),
          axis.text.y = element_text(angle = 90, hjust = 0.5),
          axis.ticks = element_line(colour = "ivory"),
          panel.border = element_rect(colour = "ivory"),
          panel.grid = element_blank())

# fb
# fb_grob <- ggplotGrob(fb)
# mg_top+annotation_custom(fb_grob, xmin = 19.5, xmax = 22, ymin = -33, ymax = -31)
# mg_top_grob <- ggplotGrob(mg_top)
# fb_grob <- ggplotGrob(fb)
# gg <- ggplot() +
#   # First set the x and y axis values so we know what the ranges are
#   # in order to make it easier to place our facets
#     coord_equal(xlim = c(0, 18), ylim = c(0, 8), expand = F) +
#   # Then we place our facetsover one another using the coordinates we created
#     annotation_custom(mg_top_grob,
#                       xmin = 0, xmax = 18, ymin = 0, ymax = 8) +
#     annotation_custom(fb_grob,
#                       xmin = 4.8, xmax = 8.4, ymin = 3, ymax = 5)
# # gg
# ggsave(plot = gg, filename = "../figures/test.pdf", width = 7.95, height = 4)
```

```{r mg-bottom}
# Establish the vector scalar for the wind
wind_uv_scalar <- 0.5

# The bottom figure (air)
mg_bottom <- ggplot(data = southern_africa_coast, aes(x = lon, y = lat)) +
  # The ocean temperature
    geom_raster(data = air_temp, aes(fill = value)) +
  # The land mass
    geom_polygon(aes(group = group), fill = NA, colour = "black", size = 0.5, show.legend = FALSE) +
    geom_path(data = africa_borders, aes(group = group)) +
  # The current vectors
    geom_segment(data = winds, aes(xend = lon + u * wind_uv_scalar, yend = lat + v * wind_uv_scalar),
                 arrow = arrow(angle = 15, length = unit(0.02, "inches"), type = "closed"), alpha = 0.4) +
  # The legend for the vector length
    geom_label(aes(x = 36, y = -37, label = "4.0 m/s\n"), size = 4, label.padding = unit(0.5, "lines")) +
    geom_segment(aes(x = 35, y = -37.5, xend = 37, yend = -37.5)) +
  # Improve on the x and y axis labels
    scale_x_continuous(breaks = seq(15, 35, 5),
                       labels = scales::unit_format("°E", sep = "")) +
    scale_y_continuous(breaks = seq(-35, -30, 5),
                       labels = c("35°S", "30°S")) +
    labs(x = NULL, y = NULL) +
  # Slightly shrink the plotting area
    coord_cartesian(xlim = c(10.5, 39.5), ylim = c(-39.5, -25.5), expand = F) +
  # Use viridis colour scheme
    scale_fill_viridis(name = "Temp.\n(°C)", option = "A") +
  # Adjust the theme
    theme_bw() +
    theme(panel.border = element_rect(fill = NA, colour = "black", size = 1))
```

```{r}
# Stick them together
full_map <- grid.arrange(gg, mg_bottom, ncol = 1)
ggsave(plot = full_map, filename = "figures/mg_full.pdf")

# Convert the figures to grobs
mg_top_grob <- ggplotGrob(mg_top)
fb_grob <- ggplotGrob(fb)
mg_bottom_grob <- ggplotGrob(mg_bottom)

# Stick them together
gg <- ggplot() +
  # First set the x and y axis values so we know what the ranges are
  # in order to make it easier to place our facets
    coord_equal(xlim = c(1, 10), ylim = c(1, 10), expand = F) +
  # Then we place our facetsover one another using the coordinates we created
    annotation_custom(mg_top_grob,
                      xmin = 1, xmax = 10, ymin = 5.5, ymax = 10) +
    annotation_custom(fb_grob,
                      xmin = 3.2, xmax = 5.7, ymin = 6.5, ymax = 8) +
    annotation_custom(mg_bottom_grob,
                      xmin = 1, xmax = 10, ymin = 1, ymax = 5.5)
# gg
ggsave(plot = gg, filename = "../figures/mg_full.pdf", width = 6, height = 6)
```

## Summary
The developments in the gridding system have brought the potential for using ggplot for these more complex maps forward quite a bit. But there is still a long way to go. Even with the enghanced functionality from version 2+ getting everything in the right place is incredibly finicky. I definitely spent more time adjusting the final grobs than I did on all of the other steps combined. It does look very pretty though.

```{r}
knitr::include_graphics("../figures/mg_full.pdf")
```

**Figure 1**: Map showing the southern tip of the African continent. The top panel shows the typical sea surface temperature and surface currents on January 1st. The bottom panel likewise shows the typical surface air temperatures and winds on any given January 1st.